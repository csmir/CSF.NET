using CSF.Core;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;

namespace CSF.Helpers
{
    /// <summary>
    ///     A set of helper methods to populate and configure an <see cref="IServiceCollection"/>.
    /// </summary>
    [EditorBrowsable(EditorBrowsableState.Advanced)]
    public static class ServiceHelpers
    {
        /// <summary>
        ///     Configures the <see cref="IServiceCollection"/> to support use of a <see cref="CommandManager"/>.
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="configureDelegate">A delegate to configure the <see cref="CommandConfiguration"/> used to set up the <see cref="CommandManager"/> to be generated by this <see cref="IServiceCollection"/>.</param>
        /// <returns>The same <see cref="IServiceCollection"/> for call chaining.</returns>
        public static IServiceCollection ConfigureCommands(this IServiceCollection collection, [DisallowNull] Action<CommandConfiguration> configureDelegate)
        {
            collection.ConfigureCommands<CommandManager>(configureDelegate);

            return collection;
        }

        /// <summary>
        ///     Configures the <see cref="IServiceCollection"/> to support use of <typeparamref name="T"/>, an implementation of <see cref="CommandManager"/>.
        /// </summary>
        /// <typeparam name="T">The <see cref="CommandManager"/> implementation to be generated by this <see cref="IServiceCollection"/>.</typeparam>
        /// <param name="collection"></param>
        /// <param name="configureDelegate">A delegate to configure the <see cref="CommandConfiguration"/> for setting up <typeparamref name="T"/>.</param>
        /// <returns>The same <see cref="IServiceCollection"/> for call chaining.</returns>
        public static IServiceCollection ConfigureCommands<T>(this IServiceCollection collection, [DisallowNull] Action<CommandConfiguration> configureDelegate)
            where T : CommandManager
        {
            var configuration = new CommandConfiguration();

            configureDelegate(configuration);

            collection.AddCommandManager<T>(configuration);

            return collection;
        }

        /// <summary>
        ///     Adds the provided <see cref="CommandConfiguration"/>, all discovered <see cref="ModuleBase"/>'s and <typeparamref name="T"/> to the <see cref="IServiceCollection"/>.
        /// </summary>
        /// <typeparam name="T">The <see cref="CommandManager"/> implementation to be generated by this <see cref="IServiceCollection"/>.</typeparam>
        /// <param name="collection"></param>
        /// <param name="configuration">The configuration for setting up <typeparamref name="T"/>.</param>
        /// <returns>The same <see cref="IServiceCollection"/> for call chaining.</returns>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static IServiceCollection AddCommandManager<T>(this IServiceCollection collection, CommandConfiguration configuration)
            where T : CommandManager
        {
            collection.AddModules(configuration);

            collection.TryAddSingleton(configuration);
            collection.TryAddSingleton<T>();

            return collection;
        }

        /// <summary>
        ///     Adds all discovered <see cref="ModuleBase"/>'s based on the collection of <see cref="CommandConfiguration.Assemblies"/> in <paramref name="configuration"/>.
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="configuration">The configuration for discovering <see cref="ModuleBase"/>'s</param>
        /// <returns>The same <see cref="IServiceCollection"/> for call chaining.</returns>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static IServiceCollection AddModules(this IServiceCollection collection, CommandConfiguration configuration)
        {
            var rootType = typeof(ModuleBase);

            foreach (var assembly in configuration.Assemblies)
                foreach (var type in assembly.GetTypes())
                    if (rootType.IsAssignableFrom(type) && !type.IsAbstract && !type.ContainsGenericParameters)
                        collection.TryAddTransient(type);

            return collection;
        }

        /// <summary>
        ///     Generates a <see cref="IServiceScope"/> by resolving the configured <see cref="AsyncApproach"/> within <paramref name="configuration"/>.
        /// </summary>
        /// <param name="provider"></param>
        /// <param name="configuration">The configuration for generating <see cref="IServiceScope"/>'s</param>
        /// <returns>A <see cref="IServiceScope"/> matching the configured logic, being async when <see cref="AsyncApproach.Discard"/> is set.</returns>
        [EditorBrowsable(EditorBrowsableState.Never)]
        public static IServiceScope CreateScope(this IServiceProvider provider, CommandConfiguration configuration)
        {
            switch (configuration.ScopeApproach)
            {
                case ScopeApproach.ByAsyncApproach when configuration.AsyncApproach is AsyncApproach.Discard:
                case ScopeApproach.OnlyAsync:
                    {
                        return provider.CreateAsyncScope();
                    }
                case ScopeApproach.ByAsyncApproach when configuration.AsyncApproach is AsyncApproach.Await:
                case ScopeApproach.OnlySync:
                    {
                        return provider.CreateScope();
                    }
                default:
                    {
                        throw new NotImplementedException();
                    }
            }
        }
    }
}
